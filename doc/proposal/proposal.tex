\documentclass[12pt, a4paper, twoside]{report}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{caption}
\usepackage{pdflscape}
\usepackage{cite}
% font size could be 10pt (default), 11pt or 12 pt
% paper size coulde be letterpaper (default), legalpaper, executivepaper,
% a4paper, a5paper or b5paper
% side coulde be oneside (default) or twoside 
% columns coulde be onecolumn (default) or twocolumn
% graphics coulde be final (default) or draft 
%
% titlepage coulde be notitlepage (default) or titlepage which 
% makes an extra page for title 
% 
% paper alignment coulde be portrait (default) or landscape 
%
% equations coulde be 
%   default number of the equation on the rigth and equation centered 
%   leqno number on the left and equation centered 
%   fleqn number on the rigth and  equation on the left side
%   
\lstset{basicstyle=\scriptsize, frame=single}

\title{Proposal for an Agda UHC Backend}
\author{Philipp Hausmann \\
    4003373 \\
    }

\date{\today} 
\begin{document}


\maketitle

\tableofcontents

\chapter{General Idea}
The dependently typed language Agda is lacking a decent compiler at the time of writing. While there
exist three backends for Agda, of which one is maintained, all three have their shortcomings.
The aim of this proposal is to create a new backend for Agda, using the UHC Core language
as intermediate language to produce efficient executables. Apart from just being able to compile
Agda code, it shall also be researched how a FFI interface between Agda and Haskell can be constructed,
what restrictions apply to such a FFI binding and how it may interfere with optimizations.

\chapter{Existing Backends - WIP}
The current version of Agda has 3 backends. The MAlonzo backend targets Haskell as intermediate
language, which is then compiled using GHC. The JS backend, as it's name says, targets javascript
and is intended for compiling web applications. Lastly, the Epic backend targets the Epic language
and uses the Epic compiler to produce an executable.
We shall now look at these three backends a bit more in depth.
\section{MAlonzo}
MAlonzo is the only officially maintained backend of Agda and is able to compile the whole standard
library. This backend contains no optimizations, apart from special handling of some Agda builtin
datatypes like Nat. Instead, the MAlonzo compiler relies on GHC in that regard, which depending
on the Agda program works to differing degress. Especially in situations where the type information
present in Agda would be required to perform optimizations, the limitations of the current implementation
become apparent. (Nat example)

While this problems can be overcome, it also needs to be mentioned that the target language Haskell
is not a perfect fit for compiling Agda. As Haskell doesn't support dependent types, the produced
code contains a lot of "coerce" statements to cheat the haskell type system. Notwithstanding any
bugs in the Agda backend, this should be safe but shows that there is a mismatch between the
two languages.

\section{Epic}
The Epic backend CITE of Agda uses the Epic language CITE as intermediate language, relying on the Epic
compiler CITE to produce an executable. This backend incorporates some optimizations, but has not been
maintained. The same also applies to the Epic compiler itself, which is unmaintained too.

Nonetheless, the similarities between the UHC Core and the Epic language are striking. Together with
the well-structured code of this backend, it should be possible to reuse a good share of code.

TODO Epic Core, UHC Core

\section{JS}

\section{Feature Comparison}
TODO

\chapter{Prototype Compiler}
A prototype backend for Agda has been created, and it has been shown that it is feasible to compile
Agda using UHC Core. This prototype lacks any optimizations and contains only a rudimentary FFI
interface, which is unidirectional (Agda to Haskell). It is also restricted to compiling just one
Agda module, and support for coinduction is missing too.

\chapter{Proposal}
\section{Agda Module support}
\subsection{Parameterised Modules}
Parametrized Agda modules can be mapped to normal plain modules, where every function get's the
modules parameter as additional arguments. (see \url{http://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.Modules#param})

\section{Haskell FFI}
Writing all code in plain Agda might often be possible, but it might sometimes be more
convenient to use Haskell Code from Agda and vice versa. Having such a facility would
also allow reusing the many libraries available for Haskell, which would make using Agda
for usable applications much easier.

It would also be preferrable, if as much as possible type-safety gained by Agda could be
preserved when interacting with the Haskell world. Creating an unsafe Agda-Haskell
FFI, while being definitely easier, would risk introducing new bugs. Hence, an approach
where the type-checking works across the language boundary is the main goal, wherever
this is possible.



\subsection{Names}
The naming policies in Haskell and Agda differ. Both allow the use of unicode symbols in names, but Haskell enforces
that constructor names always start with an upper case letter. It also requires constructor names to be unique
per module, whereas Agda allows using the same name for multiple constructors.

The simplest approach is to just restrict the FFI to entities only containing names valid in both worlds.
This could be extended using a more advanced encoding to solve some of the problems, for example
by converting the first letter of the generated HS constructors to upper case.

The best case would be to have a complete encoding, mapping all possible names across the language boundary. It is not known
if such an encoding exists, given the constraint that the generated names should be human-readable.

As an alternative, it might also be a good idea to allow the users to choose the exported name of the entities themselves.
This is especially true when exporting Agda entities, as Agda features a bigger namespace.

\subsection{Plain functions and datatypes}
For simply-typed functions and datatypes, the mapping between HS and Agda is straight-forward. An example of such
a translation can be seen in listing \ref{lst:plain-agda-hs}.
\begin{figure}
\begin{subfigure}[b]{0.5\textwidth}
\begin{lstlisting}
id : {A : Set} -> A -> A
id x = x

rnk2 : {A : Set} -> A
    -> ((B : Set) -> B -> A)
rnk2 = ...

data List (A : Set) : Set where
  nil : List A
  cons : A -> List A -> List A

-- Agda doesn't support records with
-- multiple constructors. Could be
-- mapped to a normal datatype.
data MultiRecord : Set where
  Rec1 : String -> Int -> MultiRecord
  Rec2 : String -> Bool -> MultiRecord
\end{lstlisting}
\end{subfigure}
\hspace{10pt}
\begin{subfigure}[b]{0.5\textwidth}
\begin{lstlisting}
id :: forall a . a -> a
id x = x

rnk2 :: forall a . a
    -> (forall b . b -> a)
rnk2 = ..

data List a where
  Nil :: List a
  Cons :: a -> List a -> List a




data MultiRecord
  = Rec1 { f1 :: String, f2 :: Int }
  | Rec2 { f1 :: String, f3 :: Bool }
\end{lstlisting}
\end{subfigure}
\caption{The mapping between plain Agda and Haskell functions and datatypes.}
\label{lst:plain-agda-hs}
\end{figure}

The prototype discussed earlier only supports a subset of this mappings. The only discovered
issue was that in the Agda backend, types were not completely erased when translating to Core.
Although the types were translated, they are never evaluated. The UHC HS backend on the
other hand completely erases all type information.

Erasing the type parameters from Agda Code might change how expressions are evaluated,
as an expression wrapped in a type abstraction might become a naked top level
expression.
\begin{figure}
\begin{lstlisting}
-- types not erased
f = \(x : Set) -> MyVal
case f of
 ... 

-- types erased
f' = MyVal
case f' of
 ...
\end{lstlisting}
\caption{Pseudo-code illustrating the effects of type erasure.}
\label{lst:pseu-ty-eras}
\end{figure}

Listing \ref{lst:pseu-ty-eras} shows a pseudo-code illustration of the problem.
In the type-erased version, MyVal gets evaluated, but not in the non-erased version. As Agda doesn't specify the
evaluation strategy, this shouldn't violate the semantics of Agda. It is also not clear if
it is possible in the first place to write such code in Agda, as inspecting a lambda abstraction
does not make much sense.

\subsection{Depdendently typed functions and datatypes}
As with most FFI's, there is a feature-gap between the two languages involved. While for plain datatypes a clear
translation between the two worlds exist, this is no longer the case when dependent types are used.

The usual approach to bridge this gap is to let the user define translation functions, which take
values from one world translating it into the other. For the Haskell FFI, this corresponds to marhsalling
datatypes from C to HS and back. In Haskell, this translation is done on the HS side.

In contrast, \cite{Osera:2012:DI:2103776.2103779} treats the conversion functions as special entities
which live inbetween the two worlds.


I propose to adapt the HS FFI design, by forcing all translation functions to be defined in Agda.
This avoids making large changes to the Agda or Haskell language. The Agda-HS FFI itself will remain
restricted to plain types, dependent types live only inside the Agda world.

The translation function from the plain types to the dependent types could often be partial,
which will require it to either live in e.g. the Maybe monad or alternatively using Contracts/runtime checks.
Support for such contracts is out of scope for this proposal, but maybe added later on.

\subsection{Class System}
Recently, Agda has gained support for a sort-of class system using so-called instance arguments. This can
be used as seen in listing \ref{lst:agda-inst-ex}.
\begin{figure}
\lstinputlisting[firstline=12]{code/ClassAgda.agda}
\caption{Example Agda code using instance arguments.}
\label{lst:agda-inst-ex}
\end{figure}

In contrast to Haskell, there are no explicit class definitions. In the example above,
the record \texttt{Eq} doesn't differ from a normal record definition.
The Haskell Class Constraints, on the other hand, are similiar to the instance
arguments used in the definition of \texttt{test2} above.

As long as no cross-language class support is intended, the two class systems can be
regarded as completely seperate. If the amibition is to allow interaction across
language borders, matters get more complicated.

\paragraph{Translating Class Definitions}
First, we will define how to map Agda class definitions to Haskell. We assume
that class definitions are specilay marked in Agda (e.g. pragma or keyword).

For each such class definition, we translate the record fields to functions
in the Haskell class. Fields of the record, which have a class type, are
translated into a class constraint. This proposal does not give any way
to specify default values like in haskell. An example of the translation
can be seen in \ref{lst:cls-agda-hs}.
\begin{figure}
\begin{subfigure}[b]{0.5\textwidth}
\begin{lstlisting}
record Eq (A : Set) : Set where
  field
    eq : A -> A -> Bool

record Ord (A : Set) : Set where
  field
    eqInst : Eq A
    lteq : A -> A -> Bool
\end{lstlisting}
\end{subfigure}
\hspace{10pt}
\begin{subfigure}[b]{0.5\textwidth}
\begin{lstlisting}
class Eq a where
  eq :: a -> a -> Bool

class (Eq a) => Ord a where
  lteq :: a -> a -> Bool
\end{lstlisting}
\end{subfigure}
\caption{Translating Agda classes to Haskell.}
\label{lst:cls-agda-hs}
\end{figure}


Second, we also want to translate Haskell Class into Agda Classes. We only
consider classes without functional dependencies for this. An open question is
how Haskell default values should be encoded. The simplest approach would be
to just ignore the default values and treat them like normal class members.

An alternative would be to encode them explicitly in the Agda datatype, thereby
allowing Agda instances to make use of them. There are many possibilities in
how to encode this in the Agda datatype, one can be seen in listing \ref{lst:cls-hs-agda}.
\begin{figure}
\begin{subfigure}[b]{0.5\textwidth}
\begin{lstlisting}
class Eq a where
  eq :: a -> a -> Bool

class (Eq a) => Ord a where
  lteq :: a -> a -> Bool
  lt   :: a -> a -> Bool
  lt x y = (lteq x y) && not (x eq y)
\end{lstlisting}
\end{subfigure}
\hspace{10pt}
\begin{subfigure}[b]{0.5\textwidth}
\begin{lstlisting}
data HasDefault (A : Set) : Set where
  useImpl : A -> HasDefault A
  useDefault : HasDefault A

record Ord (A : Set) : Set where
  field
    eqInst : Eq A
    lteq : A -> A -> Bool
    lt' : HasDefault (A -> A -> Bool)

lt : {A : Set} {{e : Ord A}}
        -> A -> A -> Bool
lt {{o}} with Ord.lt' o
lt | useImpl x  = x
lt | useDefault = magicLtDefault
\end{lstlisting}
\end{subfigure}
\caption{Translating Haskell classes to Agda.}
\label{lst:cls-hs-agda}
\end{figure}

\paragraph{Translating Haskell instances to Agda}
Translating classes alone is not worth much, we also need to make the
instances available. For this, we define how the instances get translated.
The actual implementation of the instances will call the haskell code
behind the scenes, for example using postulates or primitives. It is worth mentioning
that this will also influence type checking in the agda world, as it will not be
able to reason about the instance definitions in the Agda world. This might makes some
of the Haskell type classes less useful inside Agda, but this doesn't apply to all of them.
An example of the translation can be seen in \ref{lst:inst-hs-agda}.
\begin{figure}
\begin{subfigure}[b]{0.5\textwidth}
\begin{lstlisting}
instance Eq Bool where
  eq x y = ....

instance Ord Bool where
  lteq = ....
  -- use default version of lt
\end{lstlisting}
\end{subfigure}
\hspace{10pt}
\begin{subfigure}[b]{0.5\textwidth}
\begin{lstlisting}
instance
  eqBool : Eq Bool
  eqBool = record
        { eq = magicCallHaskell }

instance
  ordBool : Ord Bool
  ordBool = record
        { eqInst = eqBool
        ; lteq = magicCallHaskell
        ; lt = useDefault }
\end{lstlisting}
\end{subfigure}
\caption{Translating Haskell instances to Agda.}
\label{lst:inst-hs-agda}
\end{figure}



\paragraph{Translating Agda instances to Haskell}
The translation from Agda to Haskell is very similar and can be seen in listing \ref{lst:inst-agda-hs}.
\begin{figure}
\begin{subfigure}[b]{0.5\textwidth}
\begin{lstlisting}
instance
  eqBool : Eq Bool
  eqBool = record { eq = ... }

instance
  ordBool : Ord Bool
  ordBool = record
        { eqInst = eqBool
        ; lteq = ...
        ; lt = useDefault }
\end{lstlisting}
\end{subfigure}
\hspace{10pt}
\begin{subfigure}[b]{0.5\textwidth}
\begin{lstlisting}
instance Eq Bool where
  eq x y = magicCallAgda

instance Ord Bool where
  lteq = magicCallAgda
  -- use default version of lt
\end{lstlisting}
\end{subfigure}
\caption{Translating Agda instances to Haskell.}
\label{lst:inst-agda-hs}
\end{figure}


\paragraph{Feasability}
For the most simple classes like \texttt{Eq}, implementing it is expected to be
possible without any major changes in UHC. UHC uses dictionary-passing in it's Core representation,
and it should be possible to perform this mapping for Agda Code too.

For the more complicated cases with defaults and/or nested classes, this might pose more of a challenge.
I also recommend leaving out Agda datatype/postulate classes for the time being.

\subsection{Parameterised Modules - WIP}
The Haskell Module system does have no concept of parameterised modules, therefore another representation is required. In the end,
all functions will have to get passed the module parameters explicitly. This could be done either by just prepending the module
argument list to all function definitions, or by wrapping the module parameters in a datatype and passing that around.

How should datatypes be handled?

\subsection{Type-Checking interfacing}
While a lot has been said about how to translate from Agda to Haskell and vice versa,
the question about when and by whom this translation is done has been left open. Clearly,
the UHC Haskell Compiler will need to know at least the Haskell-version of the Agda
function/datatype signatures. The same goes for the Agda type checker, which needs to
know the Agda representation of the used Haskell entitites.

As porting both UHC and Agda to a shared representation of Agda and Haskell code
is infeasible, the necessary information needs to be communicated in some other way.
This basically means either creating a preprocessor which will emit the information
necessary for the type checker, or teaching UHC the Agda language and the other way round.

Implementing Agda/Haskell support in the other compiler is likely to require extensive changes
to both code bases. Creating preprocessors or something similar is less intrusive and is expected
to be easier to implement.

This preprocessor might even be embedded into the compiler, for example Agda might create
a \".hi\" file which UHC would use for type checking (this is just speculation...). It is worth noting
that it is not possible to encode this information in a plain Haskell file. It might suffice for
exporting Agda functions to generate corresponding Haskell FFI declarations. But the Haskell FFI
by default has no way of expressing the mapping between datatypes.

Passing information from Haskell to Agda appears easiest by generating an Agda file,
which contains the correct pragmas for interfacing with the haskell code.

\subsection{Compilation Units}
Let a compilation unit be a set of files to be compiled together. The goal is to be able to compile a set of
Haskell or Agda files, which might depend on Agda or Haskell code defined in other compile units.

Support for mixing Haskell and Agda files inside the same compilation unit is not required, as this
might would require fiddling with the import chasing algorithm of both uhc and agda. Nonetheless,
it might be possible to implement this later.

\section{UHC Core Specification}
There is no complete specification of the UHC Core interface as of writing. The interface
should be documented.

\section{Optimizations - WIP}
Inductivies families, bradley
type erasure
relevance analysis
irrelevance
forcing (same as bradley paper)?
natish data types (also, when is plus a plus?)
integer-ish data types
TODO: smash, primitivise, caseopts

\section{Contracts (for FFI) - WIP}

let f be the Contract, of type "a -> b -> .... -> Y -> Dec X"

test' : a -> c -> b -> Y
test' ... = FFI CALL

test : a -> c -> b -> assertT (f, X)
test a c b = let y = assertV (f a b) (test' a c b)


\section{Cabal Integration - WIP}
long term, it would be nice to be able to compile Agda programs using Cabal and
mix it with plain Haskell packages.

\section{UHC Changes}
For the proposal laid out so far, certain changes in UHC itself appear
unavoidable. A preliminary list of this changes is as follows:

\subsection{Index Datatypes by Aspects - WIP}
TODO just an idea...
Binds inside expressions can be indexed by aspects, which does
not apply to data types. However, there may be multiple definitions
of the same data type caused by worker/wrapper style transformations/optimizations.
While this definitions could be encoded using a naming convention, a more explicit
approach may be preferrable.

\subsection{Module support for Core}
At the moment, UHC can only compile exactly one core file to an executable.
While this core file may import modules from other packages, it is not possible
to import other Core files or build a package from multiple Core files.

\subsection{UHC Library (EH99) on hackage}
UHC uses a traditional "./configure \&\& make" build process. If the parts used by the
Agda backend could be split of into a normal cabal package residing on hackage,
making this library a hard dependency of Agda might be possible.
It would also allow the cabal dependency solver to figure out a compatible
set of packages for both UHC and Agda, which may goes wrong in the current setup.
(Cabal right now needs some manual guidance to pick packages compatible with both UHC and Agda)

\subsection{Cabal support for UHC}
The cabal support for installing packages into the UHC database is broken. If this would work, it
would marginally simplfy the installation of the uhc-agda-base package.


\bibliography{bib}{}
\bibliographystyle{plain}

\end{document}
